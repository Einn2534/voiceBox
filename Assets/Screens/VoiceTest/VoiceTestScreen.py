# 
# main
#   generated by nullptr on 2025/10/10
# 

from kivy.uix.screenmanager import Screen
from kivy.lang import Builder
from kivy.core.text import LabelBase
from kivy.clock import Clock    # Kivyのメインスレッドで安全にUI更新を行うためのタイマー管理。非同期処理の中で画面を更新するときに必須。

import asyncio      # 非同期処理
import threading    # スレッド（軽量な並列実行）を扱う
import queue
import re
import time
from typing import Iterable, List, Optional

from google import genai
from google.genai import types



import traceback    # エラー発生時の詳細なスタックトレースを取得

import pyaudio      # マイク入力・スピーカー出力を扱う
import numpy as np  # 数値計算用ライブラリ 音声波形データの加工・正規化

import argparse     # コマンドライン引数の解析

from Assets.Common.Audio.DigitalSignalProcessing import text_to_tokens, synth_token_sequence



LabelBase.register(
    name="DotGothic16",
    fn_regular="Assets/Common/Font/DotGothic16-Regular.ttf",
)

Builder.load_file('Assets/Screens/VoiceTest/VoiceTestScreen.kv')

# -------------------
# Gemini API設定
# -------------------
GEMINI_API_KEY = 'AIzaSyBC0-gE_aSsMXNL0fvFApzijUkEPRC8wSc'  # APIキー
MODEL = "models/gemini-2.0-flash-live-001"

client = genai.Client(
    http_options={"api_version": "v1beta"},
    api_key=GEMINI_API_KEY,
)

CONFIG = types.LiveConnectConfig(
    system_instruction=types.Content(parts=[types.Part(text="あなたは優秀な英語AIアシスタントです。")]),
    response_modalities=["text"],
)

# -------------------
# 音声設定
# -------------------
FORMAT = pyaudio.paInt16
CHANNELS = 1
SEND_SAMPLE_RATE = 16000
RECEIVE_SAMPLE_RATE = 24000
CHUNK_SIZE = 1024
DSP_SAMPLE_RATE = 22050
pya = pyaudio.PyAudio()


# ===============================
# メインクラス
# ===============================
class VoiceTestScreen(Screen):
    """Api test screen class"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.loop = None            # asyncioイベントループ
        self.loop_thread = None     # ループ専用スレッド
        self.session = None
        self.connected = False
        self.running = False
        self.audio_in_queue = None
        self.out_queue = None
        self._speech_lock = threading.Lock()
        self._speech_queue: Optional[queue.Queue] = None
        self._speech_worker: Optional[threading.Thread] = None
        self._speech_stop_event: Optional[threading.Event] = None
        # self.model = whisper.load_model("tiny", device="cuda" if torch.cuda.is_available() else "cpu")

    def on_enter(self):
        """Just before the screen appears"""
        
        print("VoiceTest Screen Entered!")
        self.ids.apiResponse.text = "Connecting..."
        self._start_speech_worker()

        # 非同期ループを作成して別スレッドで起動
        self.loop = asyncio.new_event_loop()
        self.loop_thread = threading.Thread(target=self.loop.run_forever, daemon=True)
        self.loop_thread.start()

        # run_audio_loop() を loop にスレッドセーフに送信
        asyncio.run_coroutine_threadsafe(self.run_audio_loop(), self.loop)

    def on_leave(self):
        """Just before leaving the screen"""
        self.running = False
        if hasattr(self, "audio_stream") and self.audio_stream:
            self.audio_stream.close()
        self._stop_speech_worker()

    async def run_audio_loop(self):
        """Gemini Live Connection Loop"""
        try:
            async with (
                client.aio.live.connect(model=MODEL, config=CONFIG) as session,
                asyncio.TaskGroup() as tg,
            ):
                self.session = session
                self.audio_in_queue = asyncio.Queue()
                self.out_queue = asyncio.Queue(maxsize=5)
                self.running = True

                # tg.create_task(self.listen_audio())
                # tg.create_task(self.send_audio())
                tg.create_task(self.receive_text())

                # Clock は Kivy のUIスレッドに安全にアクセスできる
                Clock.schedule_once(lambda dt: setattr(self.ids.apiResponse, "text", "Connected"))
                # 無限に待機して接続維持
                while self.running:
                    await asyncio.sleep(0.1)
        except Exception as e:
            print(traceback.format_exc())
            Clock.schedule_once(lambda dt: setattr(self.ids.apiResponse, "text", f"Error: {e}"))
        finally:
            self.running = False
            if hasattr(self, "audio_stream") and self.audio_stream:
                self.audio_stream.close()
            Clock.schedule_once(lambda dt: setattr(self.ids.apiResponse, "text", "Disconnect"))

    def send_text(self):
        """Sending messages from Kivy UI to Gemini"""
        if not self.session or not self.loop:
            print("セッション未接続またはループ未初期化")
            return

        user_input = self.ids.apiRequest.text.strip()
        if not user_input:
            print("入力不備")
            return

        # asyncioのコルーチンを別スレッドのループ上で安全に実行
        asyncio.run_coroutine_threadsafe(self._async_send_text(user_input), self.loop)

    async def _async_send_text(self, text):
        """
        Actual asynchronous transmission
        
        Keyword arguments:
        text -- Text to send to Gemini
        """
        try:
            await self.session.send_client_content(
                turns={"role": "user", "parts": [{"text": text}]},
                turn_complete=True
            )
        except Exception as e:
            print("send_text error:", e)

    async def receive_text(self):
        """Receive text from Gemini and reflect it in the label"""
        try:
            while self.running and self.session:
                turn = self.session.receive()
                full_text = ""

                async for response in turn:
                    if text := response.text:
                        full_text += text
                        # 部分的なテキストもリアルタイムにLabelへ反映
                        Clock.schedule_once(lambda dt, t=text: self.update_label(t))

                if full_text:
                    # 最終的な全テキストも更新
                    Clock.schedule_once(lambda dt, t=full_text: self.on_final_response(t))

        except Exception as e:
            print("receive_text error:", e)
            Clock.schedule_once(lambda dt: setattr(self.ids.apiResponse, "text", f"受信エラー: {e}"))

    def update_label(self, text):
        """
        Update a Label on the UI thread

        Keyword arguments:
        text -- Update label text
        """

        if hasattr(self, "ids") and "apiResponse" in self.ids:
            self.ids.apiResponse.text = text
        else:
            print("⚠️ Label(apiResponse) が見つかりません")

    def on_final_response(self, text):
        """Handle the final Gemini response by updating the UI and speaking."""
        self.update_label(text)
        self.enqueue_speech(text)

    def enqueue_speech(self, text: str) -> None:
        """Enqueue text for sequential speech synthesis."""
        if not text or not self.running:
            return
        self._start_speech_worker()
        assert self._speech_queue is not None
        self._speech_queue.put(text)

    # -----------------------
    # Speech helper routines
    # -----------------------

    def _start_speech_worker(self) -> None:
        """Ensure that the speech worker thread is running."""
        if self._speech_worker and self._speech_worker.is_alive():
            return
        self._speech_queue = queue.Queue()
        self._speech_stop_event = threading.Event()
        self._speech_worker = threading.Thread(target=self._speech_loop, daemon=True)
        self._speech_worker.start()

    def _stop_speech_worker(self) -> None:
        """Stop the speech worker thread and drain the queue."""
        if not self._speech_worker:
            return
        if self._speech_stop_event:
            self._speech_stop_event.set()
        if self._speech_queue is not None:
            # Wake worker if it is waiting on queue.get()
            try:
                self._speech_queue.put_nowait(None)
            except Exception:
                pass
        self._speech_worker.join(timeout=1.0)
        self._speech_worker = None
        self._speech_queue = None
        self._speech_stop_event = None

    def _speech_loop(self) -> None:
        """Background worker consuming queued text and playing audio sequentially."""
        assert self._speech_queue is not None
        assert self._speech_stop_event is not None
        while not self._speech_stop_event.is_set():
            try:
                item = self._speech_queue.get(timeout=0.1)
            except queue.Empty:
                continue

            if item is None:
                continue

            for phrase in self._iterate_phrases(item):
                if self._speech_stop_event.is_set() or not self.running:
                    break
                self._play_phrase(phrase)
                time.sleep(0.12)

    def _iterate_phrases(self, text: str) -> Iterable[str]:
        """Split long text into manageable phrases for more fluent speech."""
        normalized = re.sub(r"\s+", " ", text.replace("\n", " ")).strip()
        if not normalized:
            return []

        punctuation = set("。．.!?！？")
        parts = re.split(r"([。．.!?！？])", normalized)
        buffer = ""
        phrases: List[str] = []
        for part in parts:
            if not part:
                continue
            buffer += part
            if part in punctuation or len(buffer) >= 60:
                phrase = buffer.strip()
                if phrase:
                    phrases.append(phrase)
                buffer = ""
        if buffer.strip():
            phrases.append(buffer.strip())
        return phrases

    def _play_phrase(self, text: str) -> None:
        """Convert a phrase to audio and play it synchronously."""
        if not text or not self.running:
            return

        stream = None
        try:
            raw_tokens = text_to_tokens(text)

            # ``text_to_tokens`` は Python の ``list`` を返す設計だが、将来的な変更や
            # 例外的な入力に備え、ブーリアン評価が安全に行える通常の ``list`` へと
            # 正規化しておく。NumPy 配列は ``if tokens`` などで真偽値評価すると
            # ``ValueError`` を投げるため、一次元にフラット化したリストへ変換する。
            if raw_tokens is None:
                tokens: List[str] = []
            elif isinstance(raw_tokens, np.ndarray):
                tokens = raw_tokens.ravel().tolist()
            elif isinstance(raw_tokens, list):
                tokens = raw_tokens
            elif isinstance(raw_tokens, tuple):
                tokens = list(raw_tokens)
            elif isinstance(raw_tokens, str):
                tokens = [raw_tokens]
            else:
                try:
                    tokens = list(raw_tokens)
                except TypeError:
                    tokens = [raw_tokens]

            if not tokens:
                print("speak_text: no speakable tokens")
                return

            waveform = synth_token_sequence(tokens, sampleRate=DSP_SAMPLE_RATE)
            audio = np.clip(waveform, -1.0, 1.0)
            audio_int16 = (audio * 32767.0).astype(np.int16)

            if not self.running:
                return

            with self._speech_lock:
                stream = pya.open(
                    format=FORMAT,
                    channels=CHANNELS,
                    rate=DSP_SAMPLE_RATE,
                    output=True,
                )
                stream.write(audio_int16.tobytes())
        except Exception as speak_error:
            print("speak_text error:", speak_error)
        finally:
            if stream is not None:
                try:
                    stream.stop_stream()
                except Exception:
                    pass
                stream.close()
