# 
# main
#   generated by nullptr on 2025/10/10
# 

from __future__ import annotations

import importlib
import threading
from typing import Optional

import numpy as np
import pyaudio
from kivy.clock import Clock
from kivy.core.clipboard import Clipboard
from kivy.lang import Builder
from kivy.uix.screenmanager import Screen


Builder.load_file('Assets/Screens/VoiceTest/VoiceTestScreen.kv')

FORMAT = pyaudio.paInt16
CHANNELS = 1
SEND_SAMPLE_RATE = 16000
CHUNK_SIZE = 1024

pya = pyaudio.PyAudio()


class VoiceTestScreen(Screen):
    """Screen that records the microphone and converts speech to text."""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self._recording = False
        self._record_thread: Optional[threading.Thread] = None
        self._frames: list[bytes] = []
        self.audio_stream = None
        self._whisper_model = None
        self._load_error: Optional[str] = None
        self._whisper_spec = importlib.util.find_spec("whisper")

    def on_enter(self):
        """Prepare the screen state when it becomes visible."""
        print("VoiceTest Screen Entered!")
        self.ids.apiResponse.text = "ここに音声の書き起こしが表示されます"
        self._update_status("待機中")

    def on_leave(self):
        """Ensure recording is stopped when leaving the screen."""
        self.cancel_recording()

    # ------------------------------------------------------------------
    # UI helpers
    # ------------------------------------------------------------------
    def _update_status(self, message: str) -> None:
        display = f"[b]{message}[/b]" if message else ""
        Clock.schedule_once(lambda dt: setattr(self.ids.recordStatus, "text", display))

    def _update_transcript(self, text: str) -> None:
        Clock.schedule_once(lambda dt: setattr(self.ids.apiResponse, "text", text))

    def clear_transcript(self) -> None:
        """Clear the transcript output."""
        self._update_transcript("ここに音声の書き起こしが表示されます")
        self._update_status("待機中")

    def copy_to_clipboard(self) -> None:
        """Copy the current transcript to the system clipboard."""
        text = self.ids.apiResponse.text.strip()
        if not text:
            self._update_status("コピーするテキストがありません")
            return
        Clipboard.copy(text)
        self._update_status("テキストをコピーしました")

    # ------------------------------------------------------------------
    # Recording controls
    # ------------------------------------------------------------------
    def start_recording(self) -> None:
        """Start capturing audio from the default microphone."""
        if self._recording:
            self._update_status("録音中です")
            return
        if self._record_thread and self._record_thread.is_alive():
            self._update_status("前回の録音を停止中です。少し待ってから再度お試しください")
            return

        self._frames.clear()
        self._recording = True
        self._update_status("録音を開始しました")

        def _record_worker() -> None:
            try:
                self.audio_stream = pya.open(
                    format=FORMAT,
                    channels=CHANNELS,
                    rate=SEND_SAMPLE_RATE,
                    input=True,
                    frames_per_buffer=CHUNK_SIZE,
                )
                while self._recording:
                    data = self.audio_stream.read(CHUNK_SIZE, exception_on_overflow=False)
                    self._frames.append(data)
            except Exception as exc:
                self._update_status(f"録音エラー: {exc}")
            finally:
                if self.audio_stream is not None:
                    try:
                        self.audio_stream.stop_stream()
                    except Exception:
                        pass
                    self.audio_stream.close()
                    self.audio_stream = None
                self._recording = False
                self._record_thread = None

        self._record_thread = threading.Thread(target=_record_worker, daemon=True)
        self._record_thread.start()

    def cancel_recording(self) -> None:
        """Stop recording and discard captured audio."""
        if not self._recording:
            return
        self._recording = False
        self._update_status("録音を中止しました")
        thread = self._record_thread
        if thread and thread.is_alive():
            thread.join(timeout=1.0)
            if thread.is_alive():
                self._update_status("録音停止に時間がかかっています。数秒後に再度お試しください")
                return
        self._record_thread = None
        self._frames.clear()

    def stop_and_transcribe(self) -> None:
        """Stop the current recording and start transcription."""
        if not self._recording:
            self._update_status("録音が開始されていません")
            return

        self._recording = False
        self._update_status("録音を終了しました。解析中...")
        thread = self._record_thread
        if thread and thread.is_alive():
            thread.join(timeout=1.0)
            if thread.is_alive():
                self._update_status("録音停止を待機中です。もう一度お試しください")
                return
        self._record_thread = None
        frames = b''.join(self._frames)
        self._frames.clear()

        if not frames:
            self._update_status("音声が検出されませんでした")
            return

        threading.Thread(
            target=self._run_transcription,
            args=(frames,),
            daemon=True,
        ).start()

    # ------------------------------------------------------------------
    # Whisper integration
    # ------------------------------------------------------------------
    def _ensure_model(self) -> bool:
        if self._whisper_model is not None:
            return True
        if self._load_error is not None:
            return False
        if self._whisper_spec is None:
            self._load_error = "openai-whisper がインストールされていません。`pip install -U openai-whisper` を実行してください"
            return False

        try:
            whisper_module = importlib.import_module("whisper")
            self._whisper_model = whisper_module.load_model("small")
        except Exception as exc:  # whisper/model load errors
            self._load_error = str(exc)
            return False
        return True

    @staticmethod
    def _format_transcript(text: str) -> str:
        """Insert new lines after punctuation to improve readability."""
        stripped = text.strip()
        if not stripped:
            return "音声からテキストを取得できませんでした"

        lines: list[str] = []
        buffer: list[str] = []
        for char in stripped:
            buffer.append(char)
            if char in "。.!?！？\n":
                lines.append(''.join(buffer).strip())
                buffer.clear()
        if buffer:
            lines.append(''.join(buffer).strip())
        return '\n'.join(lines)

    def _run_transcription(self, audio_bytes: bytes) -> None:
        """Execute Whisper transcription in a background thread."""
        if not self._ensure_model():
            message = self._load_error or "モデルの読み込みに失敗しました"
            self._update_status(message)
            self._update_transcript(message)
            return

        try:
            audio_np = np.frombuffer(audio_bytes, dtype=np.int16).astype(np.float32) / 32768.0
            result = self._whisper_model.transcribe(audio_np, language="ja", task="transcribe")
            text = result.get("text", "").strip()
            formatted = self._format_transcript(text)
            self._update_transcript(formatted)
            self._update_status("書き起こしが完了しました")
        except Exception as exc:
            print(f"transcription error: {exc}")
            self._update_status(f"書き起こし中にエラーが発生しました: {exc}")

