# 
# main
#   generated by nullptr on 2025/10/10
# 

from kivy.uix.screenmanager import Screen
from kivy.lang import Builder
from kivy.clock import Clock    # Kivyのメインスレッドで安全にUI更新を行うためのタイマー管理。非同期処理の中で画面を更新するときに必須。

import asyncio      # 非同期処理
import threading    # スレッド（軽量な並列実行）を扱う

from google import genai
from google.genai import types



import traceback    # エラー発生時の詳細なスタックトレースを取得

import pyaudio      # マイク入力・スピーカー出力を扱う
import numpy as np  # 数値計算用ライブラリ 音声波形データの加工・正規化

import argparse     # コマンドライン引数の解析



Builder.load_file('Assets/Screens/VoiceTest/VoiceTestScreen.kv')

# -------------------
# Gemini API設定
# -------------------
GEMINI_API_KEY = 'AIzaSyBC0-gE_aSsMXNL0fvFApzijUkEPRC8wSc'  # APIキー
MODEL = "models/gemini-2.0-flash-live-001"

client = genai.Client(
    http_options={"api_version": "v1beta"},
    api_key=GEMINI_API_KEY,
)

CONFIG = types.LiveConnectConfig(
    system_instruction=types.Content(parts=[types.Part(text="あなたは優秀な英語AIアシスタントです。")]),
    response_modalities=["text"],
)

# -------------------
# 音声設定
# -------------------
FORMAT = pyaudio.paInt16
CHANNELS = 1
SEND_SAMPLE_RATE = 16000
RECEIVE_SAMPLE_RATE = 24000
CHUNK_SIZE = 1024
pya = pyaudio.PyAudio()


# ===============================
# メインクラス
# ===============================
class VoiceTestScreen(Screen):
    """Api test screen class"""

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.loop = None            # asyncioイベントループ
        self.loop_thread = None     # ループ専用スレッド
        self.session = None
        self.connected = False
        self.running = False
        self.audio_in_queue = None
        self.out_queue = None
        # self.model = whisper.load_model("tiny", device="cuda" if torch.cuda.is_available() else "cpu")

    def on_enter(self):
        """Just before the screen appears"""
        
        print("VoiceTest Screen Entered!")
        self.ids.apiResponse.text = "Connecting..."

        # 非同期ループを作成して別スレッドで起動
        self.loop = asyncio.new_event_loop()
        self.loop_thread = threading.Thread(target=self.loop.run_forever, daemon=True)
        self.loop_thread.start()

        # run_audio_loop() を loop にスレッドセーフに送信
        asyncio.run_coroutine_threadsafe(self.run_audio_loop(), self.loop)

    def on_leave(self):
        """Just before leaving the screen"""
        self.running = False
        if hasattr(self, "audio_stream") and self.audio_stream:
            self.audio_stream.close()

    async def run_audio_loop(self):
        """Gemini Live Connection Loop"""
        try:
            async with (
                client.aio.live.connect(model=MODEL, config=CONFIG) as session,
                asyncio.TaskGroup() as tg,
            ):
                self.session = session
                self.audio_in_queue = asyncio.Queue()
                self.out_queue = asyncio.Queue(maxsize=5)
                self.running = True

                # tg.create_task(self.listen_audio())
                # tg.create_task(self.send_audio())
                tg.create_task(self.receive_text())

                # Clock は Kivy のUIスレッドに安全にアクセスできる
                Clock.schedule_once(lambda dt: setattr(self.ids.apiResponse, "text", "Connected"))
                # 無限に待機して接続維持
                while self.running:
                    await asyncio.sleep(0.1)
        except Exception as e:
            print(traceback.format_exc())
            Clock.schedule_once(lambda dt: setattr(self.ids.apiResponse, "text", f"Error: {e}"))
        finally:
            self.running = False
            if hasattr(self, "audio_stream") and self.audio_stream:
                self.audio_stream.close()
            Clock.schedule_once(lambda dt: setattr(self.ids.apiResponse, "text", "Disconnect"))

    def send_text(self):
        """Sending messages from Kivy UI to Gemini"""
        if not self.session or not self.loop:
            print("セッション未接続またはループ未初期化")
            return

        user_input = self.ids.apiRequest.text.strip()
        if not user_input:
            print("入力不備")
            return

        # asyncioのコルーチンを別スレッドのループ上で安全に実行
        asyncio.run_coroutine_threadsafe(self._async_send_text(user_input), self.loop)

    async def _async_send_text(self, text):
        """
        Actual asynchronous transmission
        
        Keyword arguments:
        text -- Text to send to Gemini
        """
        try:
            await self.session.send_client_content(
                turns={"role": "user", "parts": [{"text": text}]},
                turn_complete=True
            )
        except Exception as e:
            print("send_text error:", e)

    async def receive_text(self):
        """Receive text from Gemini and reflect it in the label"""
        try:
            while self.running and self.session:
                turn = self.session.receive()
                full_text = ""

                async for response in turn:
                    if text := response.text:
                        full_text += text
                        # 部分的なテキストもリアルタイムにLabelへ反映
                        Clock.schedule_once(lambda dt, t=text: self.update_label(t))

                if full_text:
                    # 最終的な全テキストも更新
                    Clock.schedule_once(lambda dt, t=full_text: self.update_label(t))

        except Exception as e:
            print("receive_text error:", e)
            Clock.schedule_once(lambda dt: setattr(self.ids.apiResponse, "text", f"受信エラー: {e}"))

    def update_label(self, text):
        """
        Update a Label on the UI thread
        
        Keyword arguments:
        text -- Update label text
        """
        
        if hasattr(self, "ids") and "apiResponse" in self.ids:
            self.ids.apiResponse.text = text
        else:
            print("⚠️ Label(apiResponse) が見つかりません")